Index: src/models/Item.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package models;\n\nimport java.util.Objects;\nimport static utils.Utilities.*;\n/**\n * The responsibility of the {@code Item} class is to manage a single Item in the system.\n * Each {@code Item} item belongs to a specific Note.\n * Each {@code Item} holds a description {@code itemDescription} and a completion status {@code isItemCompleted}.\n * {@code Item} calls validation methods from the {@link utils.Utilities} class.\n * <h4>Purpose:</h4>\n * <ul>\n *   <li>Store and manage an item object's description and completed state.</li>\n *   <li>Enforce validation rules for the item description.</li>\n *   <li>Provide CRUD methods to create, list, update, and delete items.</li>\n *   <li>Prove a string representation of an item object for {@param Note} and {@param NoteAPI} called in {@param Driver}.</li>\n * </ul>\n *\n * @author Joe O'Mahony, Dave Hearne\n * @version 2.0\n */\npublic class Item {\n    /*The responsibility for this class is to manage a single Item in the\n    system. An item belongs to a specific Note.\n\n    Remember, as soon as you enter the fields in a class in IntelliJ, you can\n    GENERATE getters, setters, constructors and toString methods. They are only\n     basic methods and may need to be modified e.g. to add validation, change\n     the format of the generated toString, etc.*/\n    /**\n     * Constructs a new {@code Item} object with a description passed as a parameter.\n     * The description will be validated by {@code setItemDescription(String itemDescription)}.\n     * If {@code itemDescription} exceeds 50 characters it will be truncated, so long as a valid description\n     * is not already set.\n     *\n     * @param itemDescription the description of the item\n     */\n    public Item(String itemDescription) {\n        this.setItemDescription(itemDescription);\n    }\n    /**\n     * Constructs a new {@code Item} object with the description and completion status passed as parameters.\n     * If {@code itemDescription} exceeds 50 characters it will be truncated, if no {@code itemDescription} is passed,\n     * then it will default to \"No Description\".\n     * {@code isItemCompleted} defaults to false, i.e. {@code [TODO]} in the {@code toString()} method.\n     *\n     * @param itemDescription the description of the item (Max length of 50, default of \"No Description\")\n     * @param isItemCompleted the initial completion status of the item (default of false)\n     */\n    public Item(String itemDescription, boolean isItemCompleted) {\n        this.setItemDescription(itemDescription);\n        this.setItemCompleted(isItemCompleted); // two param constructor used\n    }\n\n/*\nEnsure that the constructor and mutators adhere to the validation rules\nlisted above.\n*/\n    /**\n     * Gets the current item object's description.\n     * @return the current item description\n     */\n    public String getItemDescription() {\n        return this.itemDescription;\n    }\n\n    /**\n     * Sets the current item object's description.\n     * @param passedItemDescription the description of the item.\n     * If {@code passedItemDescription} has not been modified already, this method truncates to 50 characters if necessary.\n     * Otherwise, no changes will be made. Checks changes through {@code \"No Description} equality with {@code ItemDescription}.\n     */\n    public void setItemDescription(String passedItemDescription) {\n        if ((passedItemDescription == null) || (passedItemDescription.isBlank())) {\n            // Do nothing\n        }\n        else if (validateStringLength(passedItemDescription, 50)) {\n            this.itemDescription = passedItemDescription;\n        }\n        else if (this.itemDescription.equals(\"No Description\")) {\n            this.itemDescription = truncateString(passedItemDescription, 50);\n        }\n        else {\n            // Do nothing\n        }\n    }\n    /**\n     * Checks whether the item is completed.\n     * @return {@code true} if the item is completed, and {@code false} (default) if the item is not completed.\n     */\n    public boolean isItemCompleted() {\n        return this.isItemCompleted;\n    }\n    /**\n     * Sets whether the item is completed.\n     * @param itemCompleted {@code true} if the item is completed, and {@code false} (default) if the item is not completed.\n     */\n    public void setItemCompleted(boolean itemCompleted) {\n        this.isItemCompleted = itemCompleted;\n    }\n\n    /**\n     * Determines whether the current item object is equal to another object.\n     * This class was barely modified from the assignment specification <b>provided method</b> {@code equals()} in\n     * the {@code Note} class.\n     * @param o the object to compare with this item object\n     * @return {@code true} if the given object equals our item object, {@code false} if not.\n     * @author Dave Hearne, Joe O'Mahony\n     */\n    @Override // MODIFIED FROM GIVEN equals NOTE CATEGORY\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Item item = (Item) o;\n        return isItemCompleted == item.isItemCompleted &&\n                Objects.equals(itemDescription, item.itemDescription); // Logical equality check\n    }\n\n/* Sample output from the toString is below (note how the boolean value\nfor isItemCompleted is set to either TODO or Completed when printing to\nthe console):\nSecondary School 3:30. [Completed]\nPrimary School 2.30. [TODO]\nBook flights. [COMPLETED]\nBook hotel. [COMPLETED]\n */\n\n    /**\n     * Creates a friendly String representation of the current item object's state, with {@code itemDescription} and\n     * {@code isItemCompleted} fields formatted/modified to text.<br />\n     * {@code isItemCompleted} will be represented as follows:\n     * <ul>\n     *     <li> if {@code isItemCompleted} is {@code true} => {@code [Completed]} is appended to the String.</li>\n     *      <li></li>if {@code isItemCompleted} is {@code false} => {@code [TODO]} is appended to the String.</li>\n     * </ul>\n     *\n     * Sample output <b>straight from assignment spec (Author: Dave Hearne)</b>: <br />\n     * Secondary School 3:30. [Completed] <br />\n     * Primary School 2.30. [TODO] <br />\n     * Book flights. [COMPLETED] <br />\n     * Book hotel. [COMPLETED] <br />\n     *\n     * @return a friendly String representation of the current item object's state.\n     */\n    @Override\n    public String toString() {\n        String itemFormat = \"\";\n        itemFormat += this.getItemDescription() + \". \";\n        if (this.isItemCompleted()) {\n            itemFormat += \"[Completed]\";\n        }\n        else {\n            itemFormat += \"[TODO]\";\n        }\n        return itemFormat;\n    }\n    /*\n    itemDescription: The description is maximum 50 characters. When creating a\n    new item, if the string is longer than 50 characters, you should truncate the\n     string to the first 50 chars (Hint see Utilities for a useful method to do\n      this) When updating itemDescription, you should only update if the value\n      is less than or equal to 50.\n    */\n    /**\n     * Description of the item.\n     * Maximum length of 50 characters.\n     * If the description provided in {@code setItemDescription()} is longer than 50 characters, it's truncated - unless\n     * {@code itemDescription} already contains a valid, non-default String, i.e. {@code itemDescription != \"No Description\"}.\n     */\n    private String itemDescription = \"No Description\";\n\n/*\n    Hint: you can use Utilities validation methods to perform the above\n     validation (see Utilities tab for more information). We have provided\n     some methods, but you would need to write more.\n*/\n\n    /*\n    isItemCompleted: A boolean value, set to false for every new item\n    (unless the two parameter constructor is used).\n     */\n    /**\n     * Completed state of the item object, default of {@code false}.\n     * Corresponds to {@code [TODO]} or {@code [Completed]} in listing methods in {@code toString()}\n     */\n    private boolean isItemCompleted = false;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/models/Item.java b/src/models/Item.java
--- a/src/models/Item.java	
+++ b/src/models/Item.java	
@@ -144,7 +144,7 @@
     @Override
     public String toString() {
         String itemFormat = "";
-        itemFormat += this.getItemDescription() + ". ";
+        itemFormat += this.getItemDescription() + ".\t";
         if (this.isItemCompleted()) {
             itemFormat += "[Completed]";
         }
Index: src/controllers/NoteAPI.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package controllers;\n\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.IOException;\nimport java.lang.ClassNotFoundException;\n\nimport com.thoughtworks.xstream.XStream;\nimport com.thoughtworks.xstream.io.xml.DomDriver;\n\nimport models.Item;\nimport models.Note;\n\nimport java.util.ArrayList;\n\nimport static utils.CategoryUtility.isValidCategory;\nimport static utils.Utilities.validRange;\n\n/**\n * The responsibility of the {@code NoteAPI} class is to manage a collection (ArrayList) of {@link Note} objects.\n * <p>\n * Each {@link Note} may contain zero or many {@link Item} objects. The {@code NoteAPI} provides:\n * <ul>\n *   <li>CRUD operations for managing notes (add, update, delete).</li>\n *   <li>Methods for archiving notes based on specific conditions (e.g., all items completed).</li>\n *   <li>Counting methods to retrieve information about how many notes/items meet various conditions\n *   (e.g. number of active or archived notes, number of items completed).</li>\n *   <li>Listing methods to display notes or items based on various conditions, such as category, priority, and item\n *   completion state.</li>\n *   <li>Searching methods to find notes by title or items by description.</li>\n *   <li>Persistence methods to save and load notes from an XML file using {@code XStream}.</li>\n * </ul>\n *\n * <h4>Purpose:</h4>\n * <ul>\n *   <li>Provide a central API for working with {@link Note} objects and their associated {@link Item} objects.</li>\n *   <li>Enforce validation rules with notes (e.g. index validation, category validation through\n *   {@link utils.CategoryUtility}).</li>\n *   <li>Support persistence.</li>\n * </ul>\n *\n * @author Joe O'Mahony, Dave Hearne\n * @version 2.0\n */\npublic class NoteAPI {\n    // The responsibility for the NoteAPI class is to manage the ArrayList of notes.\n\n    /* You will notice that we don’t have constructors, getters, setters and\n    toStrings in the above class structure. You can decide to generate these\n    boilerplate methods for your class, should you wish. */\n\n// -------------- START OF CRUD METHODS --------------\n\n    /**\n     * Adds a {@link Note} object to the notes collection.\n     *\n     * @param note note to add\n     * @return {@code true} if the {@link Note} was successfully added, {@code false} otherwise\n     */\n    public boolean add(Note note) {\n        //This method adds a note object to the ArrayList notes and returns\n        // the boolean result of the add.\n        return notes.add(note);\n    }\n\n    /**\n     * Updates an existing {@link Note} at the passed index with new details for title, priority, and category.\n     * If the index is invalid, returns {@code false}. Otherwise, updates the note and returns {@code true}.\n     *\n     * @param indexToUpdate index of the note to update\n     * @param noteTitle     new title for the note\n     * @param notePriority  new priority for the note (1 to 5)\n     * @param noteCategory  new category for the note (one of the valid categories)\n     * @return {@code true} if the update was successful; {@code false} if the update fails\n     */\n    public boolean updateNote(int indexToUpdate, String noteTitle, int notePriority, String noteCategory) {\n        /*\n        This method should attempt to retrieve the note stored at the index number passed\n        as a parameter. ==>> If the note:\n        ==>> doesn’t exist, return false, indicating the update was not successful.\n        ==>> exists, use the Note mutators to update the title, priority and category of\n             the note with the details passed in the parameter list. Finally, return\n             true to indicate a successful update.\n         */\n        if (isValidIndex(indexToUpdate)) {\n            notes.get(indexToUpdate).setNoteTitle(noteTitle);\n            notes.get(indexToUpdate).setNotePriority(notePriority);\n            notes.get(indexToUpdate).setNoteCategory(noteCategory);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Deletes the {@link Note} at the specified index, if valid.\n     * Also deletes all {@link Item} objects associated with that note (cascading delete needed for NoteAPITest).\n     * If the index is valid, deletes the {@link Note} and returns the deleted {@link Note}.\n     * Otherwise, returns {@code null}.\n     *\n     * @param indexToDelete index of the note to delete\n     * @return the deleted {@link Note} if successful,{@code null} otherwise.\n     */\n    public Note deleteNote(int indexToDelete) {\n        /* This method deletes a note at the index parameter (if that index exists)\n           and returns the deleted note object. If the index does not exist in the\n           notes list, then null should be returned. */\n        if (isValidIndex(indexToDelete)) {\n            Note noteToDelete = notes.get(indexToDelete);\n            for (int i = 0; i < noteToDelete.getItems().size(); i++) {\n                noteToDelete.deleteItem(i);\n            }\n            notes.remove(indexToDelete);\n            return noteToDelete;\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Tries to archive a {@link Note} at the given index.\n     * <ul>\n     *     <li>Index must be valid.</li>\n     *     <li>Note must not be already archived.</li>\n     *     <li>All items in the note must be completed.</li>\n     * </ul>\n     * If all above conditions are met, note is archived and {@code true} is returned, otherwise {@code false}.\n     *\n     * @param indexToArchive index of the note to archive\n     * @return {@code true} if the note was successfully archived, {@code false} otherwise\n     */\n    public boolean archiveNote(int indexToArchive) {\n        /*\n        This method checks that the index passed as a parameter is valid. ==>> If it is:\n        ==>> valid, the note is retrieved and assuming the note is NOT currently archived\n        AND all the items on the note are complete, the note is then archived and true\n        is returned. If the note exists, but is already archived or items on the note\n        are still TODO, return false.\n        ==>> invalid, return false.\n         */\n        if (isValidIndex(indexToArchive)) {\n            Note noteToArchive = notes.get(indexToArchive);\n            if (!(noteToArchive.isNoteArchived()) && (noteToArchive.checkNoteCompletionStatus())) {\n                noteToArchive.setNoteArchived(true);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Archives all active notes that have all items completed.\n     * <ul>\n     *   <li>If no active notes exist, returns \"No active notes stored\".</li>\n     *   <li>If active notes exist and some are archived by this operation, returns a string of newly archived notes.</li>\n     *   <li>If active notes exist but none are eligible for archiving, returns \"No active notes eligible for archive\".</li>\n     * </ul>\n     *\n     * @return a message with the archiving result\n     */\n    public String archiveNotesWithAllItemsComplete() {\n        /*\n        This method first checks that active notes are in the ArrayList. ==>>If:\n        ==>> no active notes exist, return “No active notes stored”.\n        ==>> active notes exist, for every active note, if ALL items in the note are complete,\n        archive the note. Also build a String of all newly archived notes and return it.\n\n        Hint: remember we wrote a method in Item - checkNoteCompletionStatus()\n         */\n        if ((notes == null) || (notes.isEmpty()) || (numberOfActiveNotes() == 0)) {\n            return \"No active notes stored\";\n        }\n\n        String archivedNotesString = \"Archived Notes:\\n\";\n        boolean archivedANoteFlag = false;\n\n        for (Note note : notes) {\n            if (!(note.isNoteArchived()) && (note.checkNoteCompletionStatus())) {\n                archivedANoteFlag = true;\n                note.setNoteArchived(true);\n                archivedNotesString += note.toString();\n            }\n        }\n\n        if (archivedANoteFlag) {\n            return archivedNotesString;\n        }\n        else { // Runs only if there are active notes, but no active note is archived\n            return \"No active notes eligible for archive\";\n        }\n\n    }\n\n// -------------- END OF CRUD METHODS --------------\n\n// -------------- START OF COUNTING METHODS --------------\n\n    /**\n     * Returns number of notes currently stored.\n     *\n     * @return total number of notes\n     */\n    public int numberOfNotes() {\n        //returns the number of notes stored in the notes ArrayList.\n        return notes.size();\n    }\n\n    /**\n     * Returns number of archived notes\n     *\n     * @return number of archived notes\n     */\n    public int numberOfArchivedNotes() {\n        // returns the number of ARCHIVED notes stored in the notes ArrayList\n        // (i.e. where isNoteArchived is set to true).\n        int archiveCtr = 0;\n        if ((notes == null) || (notes.isEmpty())) {\n            return archiveCtr;\n        }\n        else {\n            for (Note note : notes) {\n                if (note.isNoteArchived()) {\n                    archiveCtr++;\n                }\n            }\n            return archiveCtr;\n        }\n    }\n\n    /**\n     * Returns number of active notes\n     *\n     * @return number of active notes\n     */\n    public int numberOfActiveNotes() {\n        // returns the number of ACTIVE notes stored in the notes ArrayList\n        // (i.e. where isNoteArchived is set to false).\n        int activeCtr = 0;\n        if ((notes == null) || (notes.isEmpty())) {\n            return activeCtr;\n        }\n        else {\n            for (Note note : notes) {\n                if (!(note.isNoteArchived())) {\n                    activeCtr++;\n                }\n            }\n            return activeCtr;\n        }\n    }\n\n    /**\n     * Returns number of notes belonging to the passed category.\n     * Only counts the notes if the passed category is valid.\n     *\n     * @param category category to filter notes by\n     * @return number of notes in the specified category\n     */\n    public int numberOfNotesByCategory(String category) {\n        // returns the number of notes that are stored for the category passed as a parameter.\n        int categoryCtr = 0;\n        if ((notes == null) || (notes.isEmpty())) {\n            return categoryCtr;\n        }\n        else {\n            if (isValidCategory(category)) {\n                for (Note note : notes) {\n                    if (note.getNoteCategory().equals(category)) {\n                        categoryCtr++;\n                    }\n                }\n            }\n            return categoryCtr;\n        }\n    }\n\n    /**\n     * Returns number of notes with specified priority.\n     * Priority must be in range 1 to 5.\n     *\n     * @param priority priority to filter notes by\n     * @return number of notes with specified priority\n     */\n    public int numberOfNotesByPriority(int priority) {\n        // returns the number of notes that are stored for the priority passed\n        // as a parameter.\n        int priorityCtr = 0;\n        if ((notes == null) || (notes.isEmpty())) {\n            return priorityCtr;\n        }\n        else {\n            if (validRange(priority, 1, 5)) {\n                for (Note note : notes) {\n                    if (note.getNotePriority() == priority) {\n                        priorityCtr++;\n                    }\n                }\n            }\n            return priorityCtr;\n        }\n    }\n\n    /**\n     * Returns total number of items\n     *\n     * @return total number of items\n     */\n    public int numberOfItems() {\n        // adds up the number of items stored on ALL the notes in the ArrayList\n        // and returns it.\n        int totalItemsCtr = 0;\n        if ((notes == null) || (notes.isEmpty())) {\n            return totalItemsCtr;\n        }\n        else {\n            for (Note note : notes) {\n                totalItemsCtr += note.getItems().size();\n            }\n            return totalItemsCtr;\n        }\n    }\n\n    /**\n     * Returns total number of completed items\n     *\n     * @return total number of completed items\n     */\n    public int numberOfCompleteItems() {\n        // adds up the number of items stored on ALL the notes in the ArrayList where\n        // isItemCompleted is set to true. The number is then returned.\n        int totalItemsCompleteCtr = 0;\n        if ((notes == null) || (notes.isEmpty())) {\n            return totalItemsCompleteCtr;\n        }\n        else {\n            for (Note note : notes) {\n                if ((note.getItems() != null) && !(note.getItems().isEmpty())) {\n                    for (Item item : note.getItems()) {\n                        if (item.isItemCompleted()) {\n                            totalItemsCompleteCtr++;\n                        }\n                    }\n                }\n            }\n            return totalItemsCompleteCtr;\n        }\n    }\n\n    /**\n     * Returns total number of items that are not completed, i.e. to-do\n     *\n     * @return total number of items that are not completed, i.e. to-do\n     */\n    public int numberOfTodoItems() {\n        // adds up the number of items stored on ALL the notes in the ArrayList where\n        // isItemCompleted is set to false. The number is then returned.\n        int totalItemsToDoCtr = 0;\n        if ((notes == null) || (notes.isEmpty())) {\n            return totalItemsToDoCtr;\n        }\n        else {\n            for (Note note : notes) {\n                if ((note.getItems() != null) && !(note.getItems().isEmpty())) {\n                    for (Item item : note.getItems()) {\n                        if (!(item.isItemCompleted())) {\n                            totalItemsToDoCtr++;\n                        }\n                    }\n                }\n            }\n            return totalItemsToDoCtr;\n        }\n    }\n\n// -------------- END OF COUNTING METHODS --------------\n\n// -------------- START OF LISTING METHODS --------------\n\n    /**\n     * Lists all notes in a friendly format, including index.\n     * If no notes exist, returns \"No notes stored\".\n     *\n     * @return formatted string of all notes or \"No notes stored\"\n     */\n    public String listAllNotes() {\n        /*\n        ==>> If the notes list is:\n            ==>> empty, the String “No notes stored” is returned.\n            ==>> not empty, a String is returned that contains a list of all notes\n                 (including their index number)\n        */\n        if ((notes == null) || (notes.isEmpty())) {\n            return \"\\tNo notes stored\";\n        }\n\n        String allNotes = \"\";\n\n        for (int i = 0; i < notes.size(); i++) {\n            Note note = notes.get(i);\n            allNotes += \"\\t\" + i + \": \" + note.toString();\n        }\n\n        return allNotes;\n    }\n\n    /**\n     * Lists all active notes\n     * If no active notes exist, returns \"No active notes stored\".\n     *\n     * @return a formatted string of active notes or \"No active notes stored\"\n     */\n    public String listActiveNotes() {\n        /*\n        If the notes ArrayList is checked to see if Active notes are stored.\n        ==>>If active notes:\n            ==>> exist, a String is returned that contains a list of all active notes\n                (including their index number).\n            ==>>don’t exist, the String “No active notes stored” is returned.\n         */\n        if ((notes == null) || (notes.isEmpty()) || (numberOfActiveNotes() == 0)) {\n            return \"No active notes stored\";\n        }\n\n        String activeNotes = \"\";\n\n        for (Note note : notes) {\n            if (note.isNoteArchived() == false) {\n                activeNotes += notes.indexOf(note) + \": \" + note.toString();\n            }\n        }\n\n        return activeNotes;\n    }\n\n    /**\n     * Lists all archived notes\n     * If no archived notes exist, returns \"No archived notes stored\".\n     *\n     * @return a formatted string of archived notes or \"No archived notes stored\"\n     */\n    public String listArchivedNotes() {\n        /*\n        The functionality of this method is the same as the listActiveNotes()\n        functionality, except you are dealing with Archived notes, not active ones.\n         */\n        if ((notes == null) || (notes.isEmpty()) || (numberOfArchivedNotes() == 0)) {\n            return \"No archived notes stored\";\n        }\n\n        String archivedNotes = \"\";\n\n        for (Note note : notes) {\n            if (note.isNoteArchived()) {\n                archivedNotes += notes.indexOf(note) + \": \" + note.toString();\n            }\n        }\n        return archivedNotes;\n    }\n\n    /**\n     * Lists all notes belonging to a category.\n     * <ul>\n     *   <li>If no notes exist, returns \"No notes stored\".</li>\n     *   <li>If notes exist but none for the given category, returns \"No notes with category [category]\".</li>\n     *   <li>If notes exist for the category, returns a formatted list of those notes, including the total.</li>\n     * </ul>\n     *\n     * @param category the category to filter by\n     * @return a formatted string of notes in that category or the appropriate message if none relevant\n     */\n    public String listNotesBySelectedCategory(String category) {\n        /*\n        ==>> If the notes list is:\n            ==>> empty, the String “No notes stored” is returned.\n            ==>> not empty, but has no notes for the selected category, the String “No notes with category ” is returned.\n            ==>> not empty, but has notes for that category, then a String is returned that contains a list of all notes\n                (including their index number). A nice touch would be to include the number of notes in that category.\n        */\n        if ((notes == null) || (notes.isEmpty())) {\n            return \"No notes stored\";\n        }\n        if (!(isValidCategory(category)) || (numberOfNotesByCategory(category) == 0)) {\n            return \"No notes with category \" + category;\n        }\n\n        String notesByCategory = \"\";\n\n        int categoryNoteCount = numberOfNotesByCategory(category);\n        notesByCategory += categoryNoteCount + \" notes with category \" + category+ \":\\n\";\n\n        for (int i = 0; i < notes.size(); i++) {\n            Note note = notes.get(i);\n            if (note.getNoteCategory().equals(category)) {\n                notesByCategory += notes.indexOf(note) + \": \" + note.toString();\n            }\n        }\n        return notesByCategory;\n    }\n\n    /**\n     * Lists all notes with a given priority.\n     * <ul>\n     *   <li>If no notes exist, returns \"No notes stored\".</li>\n     *   <li>If notes exist but none match the given priority, returns \"No notes with priority [1-5]\".</li>\n     *   <li>If notes exist for the priority, returns a formatted list of those notes, including the count.</li>\n     * </ul>\n     *\n     * @param priority the priority to filter by [1 to 5]\n     * @return a formatted string of notes matching the priority or relevant message if none found\n     */\n    public String listNotesBySelectedPriority(int priority) {\n        /*\n        The functionality of this method is the same as the\n        listNotesBySelectedCategory(String category) functionality, except you are\n        dealing with Priority, not Category.\n         */\n        if ((notes == null) || (notes.isEmpty())) {\n            return \"No notes stored\";\n        }\n\n        if (!(validRange(priority, 1, 5)) || (numberOfNotesByPriority(priority) == 0)) {\n            return \"No notes with priority \" + priority;\n        }\n\n        String notesByPriority = \"\";\n\n        int priorityNoteCount = numberOfNotesByPriority(priority);\n        notesByPriority += priorityNoteCount + \" notes with priority \" + priority + \":\\n\";\n\n        for (int i = 0; i < notes.size(); i++) {\n            Note note = notes.get(i);\n            if (note.getNotePriority() == priority) {\n                notesByPriority += notes.indexOf(note) + \": \" + note.toString();\n            }\n        }\n        return notesByPriority;\n    }\n\n    /**\n     * Lists all items that are not completed ([TODO]).\n     * <ul>\n     *   <li>If no notes or no to-do items exist, returns \"No notes stored\".</li>\n     *   <li>Otherwise returns a list of to-do items, prefixed by note title.</li>\n     * </ul>\n     *\n     * @return a formatted string of all to-do items or \"No notes stored\"\n     */\n    public String listTodoItems() {\n        /*\n        ==>> If the notes list is:\n            ==>> empty, the String “No notes stored” is returned.\n            ==>> not empty, for every note, for all TODO items, add the note title and\n                 the TODO item to a String. This String is then returned.\n        */\n        if ((notes == null) || (notes.isEmpty()) || (numberOfTodoItems() == 0)) {\n            return \"No notes stored\";\n        }\n\n        String todoItems = \"\";\n\n        for (Note note : notes) {\n            if ((note.getItems() != null) && !(note.getItems().isEmpty())) {\n                for (Item item : note.getItems()) {\n                    if (!(item.isItemCompleted())) {\n                        todoItems += note.getNoteTitle() + \" \" + item.toString() + \"\\n\";\n                    }\n                }\n            }\n        }\n        return todoItems;\n    }\n\n    /**\n     * Lists completion status of items for a given category\n     * Shows both completed and TODO items, along with totals\n     * <ul>\n     *   <li>If no notes exist, returns \"No notes stored\".</li>\n     *   <li>If the category is invalid or no items match, returns \"No notes with category [category]\".</li>\n     *   <li>Otherwise returns a formatted string including totals and lists of completed and TODO items.</li>\n     * </ul>\n     *\n     * @param category category to filter items by\n     * @return a formatted string with completion status of items for the given category\n     */\n    public String listItemStatusByCategory(String category) {\n        /*\n        ==>> If the notes list is:\n            ==>> empty, the String “No notes stored” is returned.\n            ==>> not empty, create two strings that will eventually be returned; one for\n                containing TODO items and the other for containing Completed items. Then,\n                for every note of the chosen category, add each item to the\n                appropriate string. Finally, return a formatted result including counts.\n        */\n        if ((notes == null) || (notes.isEmpty())) {\n            return \"No notes stored\";\n        }\n        if (!(isValidCategory(category))) {\n            return \"No notes with category \" + category;\n        }\n        int completedCtr = 0;\n        String completedItems = \"\";\n        int todoCtr = 0;\n        String todoItems = \"\";\n\n        String itemStatusByCategory = \"\";\n\n        for (Note note : notes) {\n            if ((note.getItems() != null) && !(note.getItems().isEmpty())) {\n                if (note.getNoteCategory().equals(category)) {\n                    for (Item item : note.getItems()) {\n                        String itemDescription = item.getItemDescription() + \" (Note: \" + note.getNoteTitle() + \" )\\n\";\n                        if (item.isItemCompleted()) {\n                            completedItems += itemDescription;\n                            completedCtr++;\n                        }\n                        else {\n                            todoItems += itemDescription;\n                            todoCtr++;\n                        }\n                    }\n                }\n            }\n        }\n\n        itemStatusByCategory += \"Number completed: \" + completedCtr + \"\\n\";\n        itemStatusByCategory += completedItems;\n        itemStatusByCategory += \"Number TODO: \" + todoCtr + \"\\n\";\n        itemStatusByCategory += todoItems;\n\n        return itemStatusByCategory.trim();\n    }\n\n// -------------- END OF LISTING METHODS --------------\n\n// -------------- START OF FINDING/SEARCHING METHODS --------------\n\n    /**\n     * Finds and returns a {@link Note} by its index if valid, otherwise returns {@code null}.\n     *\n     * @param index index of the note to find\n     * @return {@link Note} at the given index or {@code null}\n     * */\n    public Note findNote(int index) {\n        /*\n        This method first checks that the index, passed as a parameter, is valid.\n        ==>> If it is:\n            ==>> valid, then the note at that index location in the notes ArrayList is returned.\n            ==>> not valid, null is returned.\n         */\n        if (isValidIndex(index)) {\n            return notes.get(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Searches for notes by title.\n     * <ul>\n     *   <li>If no notes stored, returns \"No notes stored\".</li>\n     *   <li>Otherwise returns a list of notes whose title contains the given search string. </li>\n     *   <ul>\n     *   <li>If none found, returns \"No notes found for: X\".</li>\n     *   </ul>\n     * </ul>\n     *\n     * @param searchTitle title substring to search for\n     * @return a formatted string of matching notes or an appropriate message if none found\n     */\n    public String searchNotesByTitle(String searchTitle) {\n        /*\n        ==>> If the notes list is:\n            ==>> empty, the String “No notes stored” is returned.\n            ==>> not empty, the title of each note is checked against the searchTitle.\n                 If a match is found, add the note and its index to a String.\n                 If no matches, return “No notes found for: ” + searchTitle.\n        */\n        if (notes == null || notes.isEmpty()) {\n            return \"No notes stored\";\n        }\n\n        String searchResultsByTitle = \"\";\n\n        for (Note note : notes) {\n            String noteTitle = note.getNoteTitle();\n            if (noteTitle.contains(searchTitle)) {\n                searchResultsByTitle += \"Note \" + notes.indexOf(note) + \": \" + note.toString() + \"\\n\";\n            }\n        }\n\n        if (searchResultsByTitle.isEmpty()) {\n            return \"No notes found for: \" + searchTitle;\n        }\n\n        return searchResultsByTitle;\n    }\n\n    /**\n     * Searches for items by description\n     * <ul>\n     *   <li>If no notes stored, returns \"No notes stored\".</li>\n     *   <li>Otherwise, returns a list of items whose description contains the given search string. <li>\n     *   <li>If none found, returns \"No items found for: X\".</li>\n     * </ul>\n     *\n     * @param searchItemDescription the description substring to search for\n     * @return a formatted string of matching items or an appropriate message if none found\n     */\n    public String searchItemByDescription(String searchItemDescription) {\n        /*\n        ==>> If the notes list is:\n            ==>> empty, the String “No notes stored” is returned.\n            ==>> not empty, for each note and each item in that note,\n                 if the item’s description matches, add it to the results String.\n                 If no matches found, return \"No items found for: \" + searchItemDescription.\n        */\n        if (notes == null || notes.isEmpty()) {\n            return \"No notes stored\";\n        }\n\n        String searchResultsByDescription = \"\";\n\n        for (Note note : notes) {\n            if ((note.getItems() != null) && !(note.getItems().isEmpty())) {\n                for (Item item : note.getItems()) {\n                    if (item.getItemDescription().contains(searchItemDescription)) {\n                        int noteIndex = notes.indexOf(note); // explicit because getting confusing with multiple indexes\n                        int itemIndex = note.getItems().indexOf(item);\n                        searchResultsByDescription += noteIndex + \": \" + note.getNoteTitle() + \"\\n\"\n                                + itemIndex + \": \" + item.toString() + \"\\n\";\n                    }\n                }\n            }\n        }\n        if (searchResultsByDescription.isEmpty()) {\n            return \"No items found for: \" + searchItemDescription;\n        }\n        return searchResultsByDescription;\n    }\n\n// -------------- END OF FINDING/SEARCHING METHODS --------------\n\n    // -------------- SINGLE HELPER METHOD IMPORTANT --------------\n\n    /**\n     * Checks if provided index is valid for the notes collection.\n     *\n     * @param index index to validate\n     * @return {@code true} if index is within the valid range; {@code false} otherwise\n     */\n    public boolean isValidIndex(int index) {\n        /*\n        This helper method will be used by several methods below,\n        so it is a good idea to write it first!!!!\n        isValidIndex(int) - This method checks that the index, passed as a parameter\n        is a valid index in the notes ArrayList. If it is a valid index, return true.\n         If invalid, return false.\n         */\n        return (validRange(index, 0, (this.notes.size()) - 1));\n    }\n\n    // -------------- TWO PERSISTENCE METHODS  --------------\n\n    /**\n     * Loads the notes from an XML file (\"notes.xml\") into the notes ArrayList using {@link XStream} and {@link DomDriver}.\n     * Relevant classes added to avoid security warnings. <b>This method was taken from lecture notes.</b>\n     * @throws IOException if there is an issue reading the file\n     * @throws ClassNotFoundException if the classes are not found\n     * @author Dave Hearne\n     */\n    public void load() throws IOException, ClassNotFoundException {\n        // this method saves the notes ArrayList to an XML file on your hard disk.\n        XStream xstream = new XStream(new DomDriver());\n        // ------------------ PREVENT SECURITY WARNINGS-----------------------------\n        // The Note class is what we are reading in.\n        // Modify to include others if needed by modifying the next line,\n        // add additional classes inside the braces, comma separated\n        Class<?>[] classes = new Class[]{Note.class, Item.class, NoteAPI.class};\n\n        XStream.setupDefaultSecurity(xstream);\n        xstream.allowTypes(classes);\n        // -------------------------------------------------------------------------\n\n        ObjectInputStream is = xstream.createObjectInputStream(new FileReader(\"notes.xml\"));\n        notes = (ArrayList<Note>) is.readObject();\n        is.close();\n    }\n\n    /**\n     * Saves the current notes ArrayList to an XML file (\"notes.xml\") using @link XStream} and {@link DomDriver}.\n     * Relevant classes added to avoid security warnings. <b>This method was taken from lecture notes.</b>\n     * @throws Exception if an error occurs during the save\n     * @author Dave Hearne\n     */\n    public void save() throws Exception {\n        // this method loads the XML file previously stored on your hard disk into the\n        // notes ArrayList.\n        XStream xstream = new XStream(new DomDriver());\n\n        // ------------------ PREVENT SECURITY WARNINGS-----------------------------\n        // The Note class is what we are reading in.\n        // Modify to include others if needed by modifying the next line,\n        // add additional classes inside the braces, comma separated\n        Class<?>[] classes = new Class[]{Note.class, Item.class, NoteAPI.class};\n\n        XStream.setupDefaultSecurity(xstream);\n        xstream.allowTypes(classes);\n        // -------------------------------------------------------------------------\n\n        ObjectOutputStream out = xstream.createObjectOutputStream(new FileWriter(\"notes.xml\"));\n        out.writeObject(notes);\n        out.close();\n    }\n\n    /**\n     * The ArrayList of {@link Note} objects\n     * Initially empty when the object is created, populated through CRUD operations.\n     */\n    private ArrayList<Note> notes = new ArrayList<Note>();\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/controllers/NoteAPI.java b/src/controllers/NoteAPI.java
--- a/src/controllers/NoteAPI.java	
+++ b/src/controllers/NoteAPI.java	
@@ -392,14 +392,14 @@
                  (including their index number)
         */
         if ((notes == null) || (notes.isEmpty())) {
-            return "\tNo notes stored";
+            return "No notes stored";
         }
 
         String allNotes = "";
 
         for (int i = 0; i < notes.size(); i++) {
             Note note = notes.get(i);
-            allNotes += "\t" + i + ": " + note.toString();
+            allNotes += i + ": " + note.toString();
         }
 
         return allNotes;
